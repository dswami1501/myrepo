All Hooks
=========
Here are scenarios for practicing each of the React hooks:

1. useState
=================
1.1) Counter: Manage a count value and increment or decrement it.
import { useState } from "react"; //{ useState }: The curly braces {} indicate a named import. Named imports allow you to import specific pieces (exports) 
								  //from a module. In this case, useState is one of the named exports from the React module.

function App() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount((prevCount) => prevCount + 1);
  };

  const decrement = () => setCount((prevCount) => prevCount - 1);

  return (
    <div className="App"> //className: In React, className is used instead of the standard HTML class attribute because class is a reserved keyword 
						  //in JavaScript. className is how you apply CSS classes to a React component.
      <h1>Counter:- {count}</h1>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
}

export default App;

1.2) Form Input: Track and update the state of a text input field.
import { useState } from "react";

function App() {
  const [inputValue, setInputValue] = useState("");

  const changeInput = (e) => {
    setInputValue(e.target.value);e: This is the event object passed to the event handler. It contains information about the event that occurred.
								  target: This is a property of the event object that refers to the element that triggered the event.
								value: This is a property of the target element (usually an input, textarea, or select element) 
									   that contains the current 	value of that element.
  };

  return (
    <div className="App">
      <h1>InputValue:- {inputValue}</h1>
      <label>
        Enter Text
        <input type="text" value={inputValue} onChange={changeInput} />
      </label>
    </div>
  );
}

export default App;

1.3) User Profile: Store and update user information like name and email.
import { useState } from "react";

function App() {
  const [profile, setProfile] = useState({
    name: "",
    email: "",
  });

  const changeName = (e) => {
    setProfile((prevProfile) => ({ ...prevProfile, name: e.target.value }));
  };

  const changeEmail = (e) => {
    setProfile((prevProfile) => {
      return { ...prevProfile, email: e.target.value };
    });
  };

  return (
    <div className="App">
      <h1>
        UserName:- {profile.name}
        Email:- {profile.email}
      </h1>
      <form>
        <label>
          Enter UserName:
          <input type="text" value={profile.name} onChange={changeName} />
        </label>
        <label>
          Enter Email:
          <input type="text" value={profile.Email} onChange={changeEmail} />
        </label>
      </form>
    </div>
  );
}

export default App;

1.4) Toggle: Implement a toggle switch for showing/hiding elements.
import { useState } from "react";
import "./styles.css";

function App() {
  const [toggle, setToggle] = useState(false);

  const handleToggle = () => {
    setToggle(!toggle);
  };

  return (
    <div className="App">
      <button onClick={handleToggle}>{toggle ? "Hide" : "Show"} Element</button>
      {toggle && (
        <div style={{ marginBottom: "10px" }}>
          <h1>I am Toggle Element</h1>
        </div>
      )}
    </div>
  );
}

export default App;

1.5)Theme: Switch between light and dark mode themes.
import { useState } from "react";

function App() {
  const [theme, setTheme] = useState("light");

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === "light" ? "dark" : "light"));
  };

  const themeStyles = {
    light: {
      backgroundColor: "#fff",
      color: "#000",
    },
    dark: {
      backgroundColor: "#333",
      color: "#fff",
    },
  };

  return (
    <div style={theme === "light" ? themeStyles.light : themeStyles.dark}>
      <h1>{theme === "light" ? "Light Mode" : "Dark Mode"}</h1>
      <button onClick={toggleTheme}>
        Switch to {theme === "light" ? "Dark" : "Light"} Mode
      </button>
    </div>
  );
}

export default App;
=======================================================================================================================

2. useEffect
=============
2.1) Fetching Data: Fetch data from an API when the component mounts.
import { useState, useEffect } from "react";

function App() {
  const [loading, setLoading] = useState(true);
  const [fact, setFacts] = useState("");
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch("https://catfact.ninja/fact");
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        const data = await response.json();
        setFacts(data.fact);
      } catch (error) {
        setError(error);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  if (loading) {
    return <p>Loading...</p>;
  }
  if (error) {
    return <p>Error {error}</p>;
  }

  return (
    <div className="App">
      <h1>Cat Fact</h1>
      <p>{fact}</p>
    </div>
  );
}

export default App;

2.2) Event Listener: Add and clean up an event listener for window resizing.
import { useState, useEffect } from "react";

function App() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    // Add event listener for window resize
    window.addEventListener('resize', handleResize);

    // Clean up the event listener on component unmount
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // Empty dependency array ensures this effect runs only on mount and unmount

  return (
    <div>
      <h1>Window Size</h1>
      <p>Width: {windowSize.width}px</p>
      <p>Height: {windowSize.height}px</p>
    </div>
  );
}

export default App;

2.3) Subscription: Set up a subscription to a data source and clean it up on component unmount.
import { useState, useEffect } from "react";

function App() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // Function to handle data updates
    const handleDataUpdate = (newData) => {
      setData(newData);
    };

    // Subscribe to the data source
    const unsubscribe = DataSource.subscribe(handleDataUpdate);

    // Clean up subscription on unmount
    return () => {
      unsubscribe();
    };
  }, []); // Empty dependency array ensures this runs only once

  return (
    <div>
      <h1>Data Subscription</h1>
      <p>{data ? data : "No data yet..."}</p>
    </div>
  );
}

export default App;

const DataSource = {
  subscribe: (abc) => {
    // Simulate a subscription
    const intervalId = setInterval(() => {
      abc(`Data update at ${new Date().toLocaleTimeString()}`);
    }, 1000);

    // Return a function to unsubscribe
    return () => clearInterval(intervalId);
  },
};
Explanation:
============
i) Data Source Simulation: A mock DataSource object simulates subscribing to a data source and periodically calls a callback(abc) with new data.
ii) useEffect Hook:
*) Subscribes to the data source when the component mounts.
*) Returns a cleanup function that unsubscribes from the data source when the component unmounts.
iii) Data State: Uses useState to manage the data received from the subscription.
iv) Rendering: Displays the data or a message if no data is yet received.

2.4) Local Storage: Save and retrieve user preferences from local storage.
import { useState, useEffect } from "react";

function App() {
  const [theme, setTheme] = useState("light");

  // Retrieve theme from local storage when the component mounts
  useEffect(() => {
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme) {
      setTheme(savedTheme);
    }
  }, []);

  // Save theme to local storage whenever it changes
  useEffect(() => {
    localStorage.setItem("theme", theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === "light" ? "dark" : "light"));
  };

  return (
    <div className={theme}>
      <h1>{theme === "light" ? "Light Theme" : "Dark Theme"}</h1>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
}

export default App;

Explanation
===========
i) Initial State Setup: The useState hook is used to initialize the theme state with a default value of 'light'.
ii) Retrieve from Local Storage: The first useEffect runs once when the component mounts (indicated by the empty dependency array []). 
							It checks if a theme is saved in local storage and sets it as the current theme.
iii) Save to Local Storage: The second useEffect runs whenever the theme state changes. It saves the current theme to local storage.
iv) Toggle Theme: The toggleTheme function toggles the theme between 'light' and 'dark'.

2.5) Animations: Trigger animations or transitions when certain state values change.
import React, { useState, useEffect } from 'react';
import './App.css'; // Make sure to import your CSS file

function App() {
  const [color, setColor] = useState('blue');
  const [animate, setAnimate] = useState(false);

  useEffect(() => {
    if (animate) {
      // Add a class to trigger the animation
      const timer = setTimeout(() => {
        setAnimate(false);
      }, 1000); // Duration of the animation

      // Cleanup the timer
      return () => clearTimeout(timer);
    }
  }, [animate]);

  const toggleColor = () => {
    setColor(color === 'blue' ? 'green' : 'blue');
    setAnimate(true);
  };

  return (
    <div className="App">
      <div className={`box ${animate ? 'animate' : ''}`} style={{ backgroundColor: color }}>
        Change my color!
      </div>
	  <h3>Animate: {animate.toString()}</h3>//To print boolean value
      <button onClick={toggleColor}>Toggle Color</button>
    </div>
  );
}

export default App;
*) And the corresponding CSS to handle the animation:

css
Copy code
/* App.css */
.box {
  width: 200px;
  height: 200px;
  margin: 20px auto;
  transition: background-color 1s ease;
}

.animate {
  /* Any other animation styles you want to add */
}
Explanation
=============
State Management:
==================
*) color: This state variable holds the current color of the box (blue or green).
*) animate: This state variable is used to trigger the animation class.
useEffect Hook:
================
*) The useEffect hook listens to changes in the animate state.
*) When animate becomes true, a timer is set to reset animate back to false after 1 second (the duration of the transition).
*) The timer is cleared if the component unmounts before the timeout completes to prevent memory leaks.
Toggle Color Function:
=======================
*) The toggleColor function changes the color state and sets animate to true to trigger the animation.
CSS Transition:
===============
*)The box class defines a transition for the background-color property.
*)The animate class can be used to add any additional animation styles.

By changing the color state and setting animate to true, the component smoothly transitions the background color, demonstrating how to use useEffect to trigger animations or transitions based on state changes.
=======================================================================================================================

3. useContext
===============
3.1) Theme Context: Provide and consume a theme context to manage light and dark modes.
Step 1: Create the Theme Context
First, create a ThemeContext and a provider component.
ThemeContext.js
================
import React, { createContext, useState } from 'react';

export const ThemeContext = createContext();

export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

Step 2: Create Components that Consume the Theme Context
Next, create some components that will consume the ThemeContext.
ThemedButton.js
================
import React, { useContext } from 'react';
import { ThemeContext } from './ThemeContext';

const ThemedButton = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);

  const buttonStyle = {
    backgroundColor: theme === 'light' ? '#fff' : '#333',
    color: theme === 'light' ? '#000' : '#fff',
    border: '1px solid',
    padding: '10px 20px',
    cursor: 'pointer'
  };

  return (
    <button style={buttonStyle} onClick={toggleTheme}>
      Toggle Theme
    </button>
  );
};

export default ThemedButton;
ThemedApp.js
=============
import React, { useContext } from 'react';
import { ThemeContext } from './ThemeContext';
import ThemedButton from './ThemedButton';

const ThemedApp = () => {
  const { theme } = useContext(ThemeContext);

  const appStyle = {
    backgroundColor: theme === 'light' ? '#f0f0f0' : '#121212',
    color: theme === 'light' ? '#000' : '#fff',
    minHeight: '100vh',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'column'
  };

  return (
    <div style={appStyle}>
      <h1>{theme === 'light' ? 'Light Mode' : 'Dark Mode'}</h1>
      <ThemedButton />
    </div>
  );
};

export default ThemedApp;
Step 3: Use the ThemeProvider in the Application
Finally, wrap your application in the ThemeProvider.

App.js
======
import React from 'react';
import { ThemeProvider } from './ThemeContext';
import ThemedApp from './ThemedApp';

const App = () => {
  return (
    <ThemeProvider>
      <ThemedApp />
    </ThemeProvider>
  );
};

export default App;
Full Example Structure
=======================
src/
├── App.js
├── ThemeContext.js
├── ThemedApp.js
└── ThemedButton.js
This code sets up a theme context and uses it to toggle between light and dark themes in a simple React application. The ThemeProvider provides the current theme and a function to toggle the theme to any component that consumes the context. The ThemedButton component allows the user to switch themes, and the ThemedApp component displays the current theme and renders the button.

3.2) Authentication: Manage user authentication state across the app.
An example of how to manage user authentication state across a React app using useContext.

Step 1: Create an Authentication Context
// AuthContext.js
import React, { createContext, useState, useContext } from 'react';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  const login = (userData) => {
    setUser(userData);
  };

  const logout = () => {
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  return useContext(AuthContext);
};

Step 2: Wrap Your Application with the AuthProvider
// App.js
import React from 'react';
import { AuthProvider } from './AuthContext';
import HomePage from './HomePage';
import LoginPage from './LoginPage';

function App() {
  return (
    <AuthProvider>
      <HomePage />
      <LoginPage />
    </AuthProvider>
  );
}

export default App;

Step 3: Consume the AuthContext in Components
HomePage Component
// HomePage.js
import React from 'react';
import { useAuth } from './AuthContext';

const HomePage = () => {
  const { user, logout } = useAuth();

  return (
    <div>
      <h1>Home Page</h1>
      {user ? (
        <>
          <p>Welcome, {user.name}!</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <p>Please log in.</p>
      )}
    </div>
  );
};

export default HomePage;

LoginPage Component
// LoginPage.js
import React, { useState } from 'react';
import { useAuth } from './AuthContext';

const LoginPage = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const { login } = useAuth();

  const handleSubmit = (e) => {
    e.preventDefault();
    // Here you would usually verify the username and password
    login({ name: username });
  };

  return (
    <div>
      <h1>Login Page</h1>
      <form onSubmit={handleSubmit}>
        <div>
          <label>Username:</label>
          <input 
            type="text" 
            value={username} 
            onChange={(e) => setUsername(e.target.value)} 
          />
        </div>
        <div>
          <label>Password:</label>
          <input 
            type="password" 
            value={password} 
            onChange={(e) => setPassword(e.target.value)} 
          />
        </div>
        <button type="submit">Login</button>
      </form>
    </div>
  );
};

export default LoginPage;
In this example:
===============
*) The AuthProvider component wraps the application and provides the authentication context to its children.
*) The useAuth custom hook is used to access the authentication context in any component.
*) The HomePage component displays user information and a logout button if the user is logged in.
*) The LoginPage component provides a form for logging in, updating the authentication state when the form is submitted.

3.3) Language: Use context to provide and consume the current language or locale setting.
Step 1: Create a Context
First, create a context to hold the language state and a provider component to wrap your application.
// LanguageContext.js
import React, { createContext, useState } from 'react';

const LanguageContext = createContext();

const LanguageProvider = ({ children }) => {
    const [language, setLanguage] = useState('en');

    const switchLanguage = (lang) => {
        setLanguage(lang);
    };

    return (
        <LanguageContext.Provider value={{ language, switchLanguage }}>
            {children}
        </LanguageContext.Provider>
    );
};

export { LanguageContext, LanguageProvider };

Step 2: Use the Context in a Component
Next, use the useContext hook to consume the language context in a component.
// LanguageSwitcher.js
import React, { useContext } from 'react';
import { LanguageContext } from './LanguageContext';

const LanguageSwitcher = () => {
    const { language, switchLanguage } = useContext(LanguageContext);

    return (
        <div>
            <p>Current Language: {language}</p>
            <button onClick={() => switchLanguage('en')}>English</button>
            <button onClick={() => switchLanguage('es')}>Spanish</button>
        </div>
    );
};

export default LanguageSwitcher;

Step 3: Wrap Your Application with the Provider
Finally, wrap your application with the LanguageProvider so that the context is available throughout your app.
// App.js
import React from 'react';
import { LanguageProvider } from './LanguageContext';
import LanguageSwitcher from './LanguageSwitcher';

const App = () => {
    return (
        <LanguageProvider>
            <LanguageSwitcher />
            {/* Other components can also consume the LanguageContext */}
        </LanguageProvider>
    );
};

export default App;
This setup provides a simple and effective way to manage and consume the current language setting using useContext in a React application.

3.4) User Info: Share user information across different components.
Step 1: Create a Context
// UserContext.js
import React, { createContext, useState } from 'react';

const UserContext = createContext();

export const UserProvider = ({ children }) => {
    const [user, setUser] = useState({ name: 'John Doe', email: 'john.doe@example.com' });

    return (
        <UserContext.Provider value={{ user, setUser }}>
            {children}
        </UserContext.Provider>
    );
};

export default UserContext;

Step 2: Use the Context in a Component
// UserProfile.js
import React, { useContext } from 'react';
import UserContext from './UserContext';

const UserProfile = () => {
    const { user } = useContext(UserContext);

    return (
        <div>
            <h1>User Profile</h1>
            <p>Name: {user.name}</p>
            <p>Email: {user.email}</p>
        </div>
    );
};

export default UserProfile;

Step 3: Update User Information in Another Component
// UpdateUser.js
import React, { useContext } from 'react';
import UserContext from './UserContext';

const UpdateUser = () => {
    const { user, setUser } = useContext(UserContext);

    const updateName = () => {
        setUser({ ...user, name: 'Jane Doe' });
    };

    return (
        <div>
            <h1>Update User</h1>
            <button onClick={updateName}>Change Name to Jane Doe</button>
        </div>
    );
};

export default UpdateUser;

Step 4: Bring It All Together
// App.js
import React from 'react';
import { UserProvider } from './UserContext';
import UserProfile from './UserProfile';
import UpdateUser from './UpdateUser';

const App = () => {
    return (
        <UserProvider>
            <UserProfile />
            <UpdateUser />
        </UserProvider>
    );
};

export default App;

Explanation
============
*) UserContext.js: Defines a context for user information and provides it using UserProvider.
*) UserProfile.js: Consumes the user context to display user information.
*) UpdateUser.js: Consumes the user context to update the user's name.
*)App.js: Wraps the components that need access to the user context with UserProvider.
This example demonstrates how to use useContext to share and update user information across different components in a React application.

3.5) Notifications: Manage and display notifications across the app using context.
1. Create the Notification Context
First, create a context for the notifications:
// NotificationContext.js
import React, { createContext, useState, useContext } from 'react';

// Create the context
const NotificationContext = createContext();

// Custom hook to use the notification context
export const useNotifications = () => useContext(NotificationContext);

// Notification provider component
export const NotificationProvider = ({ children }) => {
  const [notifications, setNotifications] = useState([]);

  const addNotification = (message) => {
    setNotifications([...notifications, { id: Date.now(), message }]);
  };

  const removeNotification = (id) => {
    setNotifications(notifications.filter((notification) => notification.id !== id));
  };

  return (
    <NotificationContext.Provider value={{ notifications, addNotification, removeNotification }}>
      {children}
    </NotificationContext.Provider>
  );
};

2. Create a Notification Component
Next, create a component to display notifications:
// NotificationList.js
import React from 'react';
import { useNotifications } from './NotificationContext';

const NotificationList = () => {
  const { notifications, removeNotification } = useNotifications();

  return (
    <div className="notification-list">
      {notifications.map((notification) => (
        <div key={notification.id} className="notification">
          {notification.message}
          <button onClick={() => removeNotification(notification.id)}>Dismiss</button>
        </div>
      ))}
    </div>
  );
};

export default NotificationList;

3. Use the Notification Context in Your App
Wrap your app with the NotificationProvider and use the addNotification function where needed:
// App.js
import React from 'react';
import { NotificationProvider, useNotifications } from './NotificationContext';
import NotificationList from './NotificationList';

const App = () => {
  return (
    <NotificationProvider>
      <div className="App">
        <NotificationButton />
        <NotificationList />
      </div>
    </NotificationProvider>
  );
};

// Component to trigger notifications
const NotificationButton = () => {
  const { addNotification } = useNotifications();

  return (
    <button onClick={() => addNotification('New notification!')}>
      Add Notification
    </button>
  );
};

export default App;

Summary
=========
*) NotificationContext.js: Defines the context, provider, and custom hook for notifications.
*) NotificationList.js: A component that consumes the context to display notifications.
*) App.js: Wraps the app in the NotificationProvider and uses the addNotification function to add notifications

======================================================================================================================================

4. useReducer
==============
4.1) Complex Form State: Manage the state of a complex form with multiple fields and validation.
Here is a simple example of using useReducer to manage the state of a complex form with multiple fields and validation.
import React, { useReducer } from 'react';

const initialState = {
  name: '',
  email: '',
  password: '',
  confirmPassword: '',
  errors: {}
};

const formReducer = (state, action) => {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        [action.field]: action.value
      };
    case 'SET_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: action.error
        }
      };
    case 'RESET':
      return initialState;
    default:
      return state;
  }
};

const validateForm = (state) => {
  const errors = {};
  if (!state.name) errors.name = 'Name is required';
  if (!state.email) errors.email = 'Email is required';
  if (!state.password) errors.password = 'Password is required';
  if (state.password !== state.confirmPassword) errors.confirmPassword = 'Passwords do not match';
  return errors;
};

const ComplexForm = () => {
  const [state, dispatch] = useReducer(formReducer, initialState);

  const handleChange = (e) => {
    dispatch({ type: 'SET_FIELD', field: e.target.name, value: e.target.value });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const errors = validateForm(state);
    if (Object.keys(errors).length > 0) {
      for (let field in errors) {
        dispatch({ type: 'SET_ERROR', field, error: errors[field] });
      }
    } else {
      // Submit form
      console.log('Form submitted', state);
      dispatch({ type: 'RESET' });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Name:</label>
        <input
          type="text"
          name="name"
          value={state.name}
          onChange={handleChange}
        />
        {state.errors.name && <p>{state.errors.name}</p>}
      </div>
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={state.email}
          onChange={handleChange}
        />
        {state.errors.email && <p>{state.errors.email}</p>}
      </div>
      <div>
        <label>Password:</label>
        <input
          type="password"
          name="password"
          value={state.password}
          onChange={handleChange}
        />
        {state.errors.password && <p>{state.errors.password}</p>}
      </div>
      <div>
        <label>Confirm Password:</label>
        <input
          type="password"
          name="confirmPassword"
          value={state.confirmPassword}
          onChange={handleChange}
        />
        {state.errors.confirmPassword && <p>{state.errors.confirmPassword}</p>}
      </div>
      <button type="submit">Submit</button>
    </form>
  );
};

export default ComplexForm;
Explanation:
=============
*) Initial State: Defines the initial state of the form, including the form fields and an errors object.
*) Reducer: Manages state changes based on different action types (SET_FIELD, SET_ERROR, and RESET).
*) Validation Function: Validates the form fields and returns an errors object if there are validation issues.
Form Component:
================
*) handleChange: Dispatches SET_FIELD actions to update form field values.
*) handleSubmit: Validates the form and dispatches SET_ERROR actions if there are errors. If the form is valid, it logs the form data and resets the form.
This example provides a straightforward way to handle a complex form state with validation using useReducer.

4.2) Counter with Actions: Implement a counter with increment, decrement, and reset actions.
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </div>
  );
}

export default Counter;

4.3) Todo List: Manage a list of todos with actions to add, remove, and toggle completed items.
import React, { useReducer, useState } from 'react';

const initialState = [];

const reducer = (state, action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, { id: Date.now(), text: action.payload, completed: false }];
    case 'REMOVE_TODO':
      return state.filter(todo => todo.id !== action.payload);
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo
      );
    default:
      return state;
  }
};

const TodoList = () => {
  const [todos, dispatch] = useReducer(reducer, initialState);
  const [text, setText] = useState('');

  const handleAddTodo = () => {
    dispatch({ type: 'ADD_TODO', payload: text });
    setText('');
  };

  return (
    <div>
      <h1>Todo List</h1>
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <button onClick={handleAddTodo}>Add Todo</button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <span
              style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
              onClick={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}
            >
              {todo.text}
            </span>
            <button onClick={() => dispatch({ type: 'REMOVE_TODO', payload: todo.id })}>
              Remove
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default TodoList;

4.4) Shopping Cart: Handle adding, removing, and updating items in a shopping cart.
import React, { useReducer } from 'react';

// Initial state for the shopping cart
const initialState = {
  items: []
};

// Reducer function to handle actions
const cartReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      return {
        ...state,
        items: [...state.items, action.payload]
      };
    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload.id)
      };
    case 'UPDATE_ITEM':
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id ? { ...item, ...action.payload.updates } : item
        )
      };
    default:
      return state;
  }
};

const ShoppingCart = () => {
  const [state, dispatch] = useReducer(cartReducer, initialState);

  const addItem = (item) => {
    dispatch({ type: 'ADD_ITEM', payload: item });
  };

  const removeItem = (id) => {
    dispatch({ type: 'REMOVE_ITEM', payload: { id } });
  };

  const updateItem = (id, updates) => {
    dispatch({ type: 'UPDATE_ITEM', payload: { id, updates } });
  };

  return (
    <div>
      <h1>Shopping Cart</h1>
      <button onClick={() => addItem({ id: 1, name: 'Item 1', quantity: 1 })}>Add Item 1</button>
      <button onClick={() => addItem({ id: 2, name: 'Item 2', quantity: 2 })}>Add Item 2</button>
      <button onClick={() => updateItem(1, { quantity: 3 })}>Update Item 1 Quantity</button>
      <button onClick={() => removeItem(2)}>Remove Item 2</button>
      
      <ul>
        {state.items.map(item => (
          <li key={item.id}>
            {item.name} - Quantity: {item.quantity}
          </li>
        ))}
      </ul>
    </div>
  );
};

export default ShoppingCart;

4.5) Pagination: Implement pagination logic with actions to change pages and update items per page.
import React, { useReducer } from 'react';

// Initial state
const initialState = {
  currentPage: 1,
  itemsPerPage: 10,
  totalItems: 100, // Total items available
};

// Actions
const actionTypes = {
  NEXT_PAGE: 'NEXT_PAGE',
  PREV_PAGE: 'PREV_PAGE',
  SET_PAGE: 'SET_PAGE',
  SET_ITEMS_PER_PAGE: 'SET_ITEMS_PER_PAGE',
};

// Reducer function
const reducer = (state, action) => {
  switch (action.type) {
    case actionTypes.NEXT_PAGE:
      return {
        ...state,
        currentPage: Math.min(state.currentPage + 1, Math.ceil(state.totalItems / state.itemsPerPage)),
      };
    case actionTypes.PREV_PAGE:
      return {
        ...state,
        currentPage: Math.max(state.currentPage - 1, 1),
      };
    case actionTypes.SET_PAGE:
      return {
        ...state,
        currentPage: action.page,
      };
    case actionTypes.SET_ITEMS_PER_PAGE:
      return {
        ...state,
        itemsPerPage: action.itemsPerPage,
        currentPage: 1, // Reset to first page when items per page change
      };
    default:
      return state;
  }
};

// Component
const Pagination = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  const { currentPage, itemsPerPage, totalItems } = state;
  const totalPages = Math.ceil(totalItems / itemsPerPage);

  return (
    <div>
      <h2>Pagination</h2>
      <div>
        <button
          onClick={() => dispatch({ type: actionTypes.PREV_PAGE })}
          disabled={currentPage === 1}
        >
          Previous
        </button>
        <span>
          Page {currentPage} of {totalPages}
        </span>
        <button
          onClick={() => dispatch({ type: actionTypes.NEXT_PAGE })}
          disabled={currentPage === totalPages}
        >
          Next
        </button>
      </div>
      <div>
        <label>
          Items per page:
          <select
            value={itemsPerPage}
            onChange={(e) => dispatch({ type: actionTypes.SET_ITEMS_PER_PAGE, itemsPerPage: Number(e.target.value) })}
          >
            {[10, 20, 50].map(num => (
              <option key={num} value={num}>
                {num}
              </option>
            ))}
          </select>
        </label>
      </div>
    </div>
  );
};

export default Pagination;

==============================================================================================================================

5. useCallback
===============
5.1) Memoized Event Handlers: Prevent unnecessary re-renders by memoizing event handler functions.
import React, { useState, useCallback } from 'react';

// Child component that receives a memoized event handler
const Child = React.memo(({ onClick }) => {
  console.log('Child component rendered');
  return <button onClick={onClick}>Click Me</button>;
});

const Parent = () => {
  const [count, setCount] = useState(0);

  // Memoized event handler
  const handleClick = useCallback(() => {
    console.log('Button clicked');
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment Count</button>
      <Child onClick={handleClick} />
    </div>
  );
};

export default Parent;
Explanation:
=============
i) Child Component: The Child component is wrapped with React.memo to prevent re-renders unless its props change. It only re-renders if the onClick prop changes.

ii) Parent Component:

*) handleClick is memoized using useCallback. It will only be recreated if its dependencies change (which, in this case, there are none).
*) When the Increment Count button is clicked, it updates the count state, which triggers a re-render of the Parent component.
*) Since handleClick is memoized, the Child component will not re-render unless the handleClick function reference changes. 
   In this case, it does not change, so Child will not re-render when count changes.
By using useCallback, the handleClick function retains the same reference between renders, which helps to avoid unnecessary re-renders of the Child component

5.2) Changing Input: Memoize a function based on changing inputs.
Scenario: Filter a List of Items
We have a list of fruits, and we want to filter this list based on the user's search input. We'll use useCallback to memoize the filter function so that it only gets re-created when the search input changes.

import React, { useState, useCallback } from 'react';

const FruitList = () => {
  const [search, setSearch] = useState('');
  const fruits = ['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry', 'Fig', 'Grape'];

  // Memoize the filter function using useCallback
  const filteredFruits = useCallback(() => {
    return fruits.filter(fruit =>
      fruit.toLowerCase().includes(search.toLowerCase())
    );
  }, [search]);

  return (
    <div>
      <h1>Fruit List</h1>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Search for a fruit..."
      />
      <ul>
        {filteredFruits().map((fruit, index) => (
          <li key={index}>{fruit}</li>
        ))}
      </ul>
    </div>
  );
};

export default FruitList;
Explanation
===============
*) State Management: We use useState to manage the search input state.
*) Memoization with useCallback: The filteredFruits function is memoized using useCallback, so it only gets re-created when the search input changes. 
   This helps to optimize performance by avoiding unnecessary re-renders.
*) Filtering Logic: The filteredFruits function filters the list of fruits based on the search input, converting both the fruit names and the search input to lowercase for case-insensitive matching.
*) Rendering: The component renders an input field for the search and a list of filtered fruits.
This simple and user-friendly example showcases how useCallback can be used to optimize performance by memoizing a function based on changing inputs.

5.3) Form Submission: Use a memoized callback to handle form submission and avoid re-creating the function.
a simple example using useCallback to handle form submission in a React component. This example demonstrates how to use useCallback to memoize the submission handler function to avoid re-creating it on each render.

import React, { useState, useCallback } from 'react';

const SimpleForm = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  const handleSubmit = useCallback((event) => {
    event.preventDefault();
    console.log('Form submitted:', { name, email });
    // You can also send the data to an API or handle it as needed
  }, [name, email]);

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label htmlFor="name">Name:</label>
        <input
          type="text"
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="email">Email:</label>
        <input
          type="email"
          id="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </div>
      <button type="submit">Submit</button>
    </form>
  );
};

export default SimpleForm;
Explanation
============
i) State Management: name and email states are managed using useState.
ii) useCallback:
*) handleSubmit is wrapped in useCallback to ensure the function is memoized and not recreated on each render.
*) The dependencies array [name, email] ensures the function is updated only when name or email changes.
iii) Form Submission:
*) handleSubmit prevents the default form submission action and logs the form data.
*) This example is straightforward and demonstrates the use of useCallback in the context of a form submission, which can be a common interview question scenario.

5.4) List Filtering: Memoize a function that filters a list based on user input.
import React, { useState, useCallback, useMemo } from 'react';

const ListFiltering = () => {
  const [query, setQuery] = useState('');
  const [items] = useState(['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape']);

  const handleInputChange = (e) => {
    setQuery(e.target.value);
  };

  const filterItems = useCallback((items, query) => {
    return items.filter((item) => item.toLowerCase().includes(query.toLowerCase()));
  }, []);

  const filteredItems = useMemo(() => filterItems(items, query), [items, query, filterItems]);

  return (
    <div>
      <input type="text" value={query} onChange={handleInputChange} placeholder="Search..." />
      <ul>
        {filteredItems.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
};

export default ListFiltering;

5.5) Debounced Input: Implement a debounced search input using a memoized callback.
import React, { useState, useCallback } from 'react';

const DebouncedInput = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [debouncedTerm, setDebouncedTerm] = useState('');

  const debounce = (func, delay) => {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        func(...args);
      }, delay);
    };
  };

  const handleSearch = useCallback(
    debounce((term) => {
      setDebouncedTerm(term);
      console.log('Searching for:', term);
    }, 500),
    [] // The empty dependency array ensures the callback is created only once
  );

  const handleChange = (event) => {
    setSearchTerm(event.target.value);
    handleSearch(event.target.value);
  };

  return (
    <div>
      <input
        type="text"
        value={searchTerm}
        onChange={handleChange}
        placeholder="Search..."
      />
      <p>Search term: {debouncedTerm}</p>
    </div>
  );
};

export default DebouncedInput;
Explanation
============
i)State Management: We have two pieces of state: searchTerm for the current input value and debouncedTerm for the debounced value.
ii)Debounce Function: A helper function debounce takes a function func and a delay delay, and returns a new function that delays the execution of func until after delay milliseconds have passed since the last time it was invoked.
iii)useCallback: We use useCallback to memoize the debounced version of the handleSearch function. This ensures that the debounce timer is not reset on every render.
iv)handleChange: This function updates the searchTerm state and calls the debounced handleSearch function with the current input value.
v)Rendering: An input field allows the user to type a search term, and the debounced search term is displayed below it.
This example demonstrates how to use useCallback to optimize performance by avoiding unnecessary re-creations of the debounced function.

Q)Explain this function:
Ans)const debounce = (func, delay) => {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        func(...args);
      }, delay);
    };
  };

The debounce function is a utility that helps delay the execution of a given function (func) until after a specified amount of time (delay) has passed since the last time the function was invoked. Here's a breakdown of how it works:

Function Breakdown
==================
const debounce = (func, delay) => {
  let timer; // A variable to store the timeout ID

  return (...args) => {
    clearTimeout(timer); // Clears the previous timeout, if any

    // Sets a new timeout
    timer = setTimeout(() => {
      func(...args); // Calls the function with the provided arguments
    }, delay); // Executes after the specified delay
  };
};
Detailed Explanation
Arguments:

func: The function that you want to debounce.
delay: The amount of time (in milliseconds) to wait before executing func.
Timer Variable:

let timer; declares a variable timer that will hold the identifier of the timeout.
Returning a New Function:

The debounce function returns a new function that takes any number of arguments (...args).
Clearing the Timeout:

clearTimeout(timer); is called to clear any existing timeout. This prevents the previous func call from being executed if the new function is invoked again within the delay period.
Setting a New Timeout:

timer = setTimeout(() => { func(...args); }, delay); sets a new timeout that will execute func after the specified delay.
func(...args); ensures that the function is called with the arguments it received.

==============================================================================================================================

6. useMemo
===========
6.1) Expensive Calculations: Optimize performance by memoizing results of expensive calculations.
import React, { useState, useMemo } from 'react';

function ExpensiveComponent() {
  const [number, setNumber] = useState(0);
  const [showResult, setShowResult] = useState(true);

  // Function that performs an expensive calculation
  const calculateExpensiveResult = (num) => {
    console.log('Calculating...');
    let result = 0;
    for (let i = 0; i < 1000000000; i++) {
      result += num;
    }
    return result;
  };

  // Memoized result of the expensive calculation
  const expensiveResult = useMemo(() => calculateExpensiveResult(number), [number]);

  return (
    <div>
      <h1>Expensive Calculation</h1>
      <input
        type="number"
        value={number}
        onChange={(e) => setNumber(parseInt(e.target.value, 10))}
      />
      <button onClick={() => setShowResult(!showResult)}>
        Toggle Result
      </button>
      {showResult && <p>Expensive Result: {expensiveResult}</p>}
    </div>
  );
}

export default ExpensiveComponent;
Explanation:
==============
*) calculateExpensiveResult: A function that simulates an expensive calculation by performing a large number of operations.
*) useMemo: Used to memoize the result of calculateExpensiveResult. The calculation is only re-run when number changes.
*) expensiveResult: The memoized value which is recalculated only when the number changes, preventing unnecessary recalculations.

6.2) Filtered Data: Memoize a list of filtered items based on search criteria.
import React, { useState, useMemo } from 'react';

const ItemList = () => {
  const [items, setItems] = useState([
    'Apple',
    'Banana',
    'Cherry',
    'Date',
    'Fig',
    'Grape'
  ]);
  const [searchTerm, setSearchTerm] = useState('');

  // Memoize the filtered items
  const filteredItems = useMemo(() => {
    console.log('Filtering items...');
    return items.filter(item =>
      item.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [searchTerm, items]); // Dependencies: searchTerm and items

  return (
    <div>
      <input
        type="text"
        placeholder="Search..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      <ul>
        {filteredItems.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
};

export default ItemList;
Explanation:
============
i) State Management:
*) items holds the list of items.
*) searchTerm tracks the user's input for filtering.
ii) Filtering with useMemo:
*) filteredItems is computed using useMemo to ensure the filtering logic is only recalculated when searchTerm or items change.
*) The console.log statement helps illustrate when filtering is happening.
iii) Rendering:
*) An input field updates searchTerm as the user types.
*) The filtered items are displayed in a list.
This code ensures that the filtering operation is optimized and only recalculates when necessary, improving performance especially with larger datasets

6.3) Derived State: Compute derived state values that depend on multiple state variables.
Scenario
You have a component that tracks two state variables: a and b. You want to compute the sum of these two values and display it. Since the sum calculation is a simple arithmetic operation, it’s not expensive, but this example demonstrates how to use useMemo to prevent unnecessary recalculations.

import React, { useState, useMemo } from 'react';

function SumCalculator() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);

  // Compute derived state using useMemo
  const sum = useMemo(() => {
    console.log('Calculating sum...');
    return a + b;
  }, [a, b]); // Recompute only when `a` or `b` changes

  return (
    <div>
      <h1>Sum Calculator</h1>
      <div>
        <label>
          A:
          <input
            type="number"
            value={a}
            onChange={(e) => setA(Number(e.target.value))}
          />
        </label>
      </div>
      <div>
        <label>
          B:
          <input
            type="number"
            value={b}
            onChange={(e) => setB(Number(e.target.value))}
          />
        </label>
      </div>
      <div>
        <h2>Sum: {sum}</h2>
      </div>
    </div>
  );
}

export default SumCalculator;
Explanation
============
i) State Variables: a and b are state variables that store the numbers input by the user.
ii) useMemo: The useMemo hook is used to compute the sum only when a or b changes. If either a or b remains unchanged, useMemo will return the previously computed sum instead of recalculating it.
iii) Dependency Array: [a, b] is the dependency array, meaning the sum will be recalculated only when a or b changes.
This example shows how useMemo can optimize performance by avoiding unnecessary recalculations of derived state values.

6.4) Dynamic Styles: Memoize dynamic style objects to avoid unnecessary re-renders.
import React, { useMemo, useState } from 'react';

const DynamicStyledComponent = () => {
  const [color, setColor] = useState('blue');
  const [size, setSize] = useState(16);

  // Memoize the style object to avoid unnecessary re-renders
  const dynamicStyle = useMemo(() => ({
    color: color,
    fontSize: `${size}px`,
    padding: '10px',
    border: '1px solid black',
    borderRadius: '4px',
    backgroundColor: 'lightgray'
  }), [color, size]); // Dependencies array

  return (
    <div>
      <div style={dynamicStyle}>
        This text has dynamic styles!
      </div>
      <button onClick={() => setColor(color === 'blue' ? 'red' : 'blue')}>
        Toggle Color
      </button>
      <button onClick={() => setSize(size === 16 ? 24 : 16)}>
        Toggle Size
      </button>
    </div>
  );
};

export default DynamicStyledComponent;
Explanation:
=============
i) State Management: color and size states are managed with useState.
ii) Memoized Style: useMemo is used to create a dynamicStyle object that is only recomputed when either color or size changes. This prevents the style object from being recreated on every render, which can help avoid unnecessary re-renders of child components that rely on this style object.
iii) Dependencies: The dependencies array for useMemo contains color and size. This means that the memoized style object will only change when one of these dependencies changes.

6.5) Data Transformation: Memoize the results of transforming or sorting datasets.
import React, { useState, useMemo } from 'react';

const App = () => {
  const [numbers, setNumbers] = useState([5, 3, 8, 1, 2]);
  const [sortOrder, setSortOrder] = useState('asc'); // 'asc' or 'desc'

  // Memoized sorted numbers
  const sortedNumbers = useMemo(() => {
    console.log('Sorting numbers...');
    return [...numbers].sort((a, b) => {
      if (sortOrder === 'asc') return a - b;
      if (sortOrder === 'desc') return b - a;
      return 0;
    });
  }, [numbers, sortOrder]); // Only recompute if numbers or sortOrder changes

  return (
    <div>
      <h1>Sorted Numbers</h1>
      <button onClick={() => setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')}>
        Toggle Sort Order (Currently: {sortOrder})
      </button>
      <ul>
        {sortedNumbers.map((num, index) => (
          <li key={index}>{num}</li>
        ))}
      </ul>
    </div>
  );
};

export default App;

==========================================================================================================================

7. useRef
===========
7.1) Access DOM Elements: Use useRef to access and manipulate DOM elements (e.g., focus an input field).
import React, { useRef } from 'react';

function FocusInput() {
  // Create a ref using useRef
  const inputRef = useRef(null);

  // Function to focus the input field
  const focusInput = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input
        ref={inputRef} // Attach the ref to the input element
        type="text"
        placeholder="Click the button to focus me"
      />
      <button onClick={focusInput}>Focus the input</button>
    </div>
  );
}

export default FocusInput;

7.2) Previous State: Keep track of the previous value of a state or prop.
import React, { useState, useRef, useEffect } from 'react';

const PreviousValueExample = () => {
  // State to keep track of the current value
  const [value, setValue] = useState(0);
  
  // Ref to keep track of the previous value
  const prevValueRef = useRef();

  // Update the ref with the current value after each render
  useEffect(() => {
    prevValueRef.current = value;
  }, [value]);

  // Access the previous value from the ref
  const prevValue = prevValueRef.current;

  return (
    <div>
      <p>Current Value: {value}</p>
      <p>Previous Value: {prevValue}</p>
      <button onClick={() => setValue(value + 1)}>Increment</button>
    </div>
  );
};

export default PreviousValueExample;

7.3) Timeouts/Intervals: Store a reference to a timeout or interval to clear it later.
import React, { useRef, useEffect, useState } from 'react';

const TimerComponent = () => {
  const [seconds, setSeconds] = useState(0);
  const intervalRef = useRef(null);

  useEffect(() => {
    // Start an interval when the component mounts
    intervalRef.current = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);

    // Cleanup function to clear the interval when the component unmounts
    return () => {
      clearInterval(intervalRef.current);
    };
  }, []);

  // Function to stop the interval manually
  const stopInterval = () => {
    clearInterval(intervalRef.current);
  };

  return (
    <div>
      <h1>Time: {seconds} seconds</h1>
      <button onClick={stopInterval}>Stop Timer</button>
    </div>
  );
};

export default TimerComponent;

7.4) Animation: store a reference to a DOM element for animation purposes.
example using useRef to store a reference to a DOM element and animate it by changing its position:

import React, { useRef, useEffect } from 'react';

const AnimatedBox = () => {
  // Create a ref to store the DOM element
  const boxRef = useRef(null);

  useEffect(() => {
    // Access the DOM element using the ref
    const box = boxRef.current;

    // Define a simple animation function
    const animate = () => {
      let position = 0;
      const interval = setInterval(() => {
        if (position >= 300) {
          clearInterval(interval);
        } else {
          position += 2;
          box.style.transform = `translateX(${position}px)`;
        }
      }, 10);
    };

    animate();
  }, []); // Empty dependency array to run the effect once on mount

  return (
    <div
      ref={boxRef}
      style={{
        width: '50px',
        height: '50px',
        backgroundColor: 'blue',
        position: 'relative'
      }}
    ></div>
  );
};

export default AnimatedBox;
Explanation:
=============
i) useRef: Creates a ref (boxRef) that will be attached to the div element.
ii) useEffect: Runs after the component mounts. It accesses the DOM element via boxRef.current and performs the animation.
iii) Animation Function: Uses setInterval to move the box horizontally by updating its transform property.
This example will animate a blue box from its original position to the right by 300 pixels. It’s a basic demonstration of how useRef can be used for direct DOM manipulation.

7.5) Form Values: Persist form values between renders without causing re-renders.
import React, { useState, useRef } from 'react';

const FormWithRef = () => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
  });

  // useRef to persist form values
  const formValuesRef = useRef({
    name: '',
    email: '',
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    
    // Update state
    setFormData((prevData) => ({
      ...prevData,
      [name]: value,
    }));
    
    // Update ref
    formValuesRef.current[name] = value;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Form submitted with values: ${JSON.stringify(formValuesRef.current)}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>
          Name:
          <input
            type="text"
            name="name"
            value={formData.name}
            onChange={handleChange}
          />
        </label>
      </div>
      <div>
        <label>
          Email:
          <input
            type="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
          />
        </label>
      </div>
      <button type="submit">Submit</button>
    </form>
  );
};

export default FormWithRef;

===========================================================================================================================

8. Custom Hooks
=================
8.1) UseLocalStorage: Create a custom hook to manage local storage state.
Custom Hook: useLocalStorage
import { useState } from 'react';

function useLocalStorage(key, initialValue) {
  // Retrieve the stored value from local storage or use the initial value
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // Save the value to local storage
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}

export default useLocalStorage;
Usage Example
Here's how you can use the useLocalStorage custom hook in a component:
import React from 'react';
import useLocalStorage from './useLocalStorage';

function App() {
  const [name, setName] = useLocalStorage('name', 'John Doe');

  return (
    <div>
      <h1>Hello, {name}!</h1>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <button onClick={() => setName('')}>Reset Name</button>
    </div>
  );
}

export default App;
Explanation
============
i)useLocalStorage Hook:
*) useState: Initializes the state with a function that tries to get the value from local storage.
*) setValue function: Updates the state and local storage with the new value. It handles both direct values and functional updates.
ii) App Component:
*) Uses the useLocalStorage hook to manage the name state.
*) Displays the name in a heading.
*) Provides an input field to update the name.
*) A button to reset the name to an empty string.
This setup ensures that the name persists in the local storage even after the page is refreshed.

8.2) UseFetch: Implement a custom hook for data fetching with loading and error states.
simple implementation of a custom useFetch hook that you can use for data fetching, including handling loading and error states:
// useFetch.js
import { useState, useEffect } from 'react';

const useFetch = (url) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        const result = await response.json();
        setData(result);
      } catch (error) {
        setError(error.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
};

export default useFetch;
Example Usage
You can use this custom useFetch hook in a functional component as shown below:
// App.js
import React from 'react';
import useFetch from './useFetch';

const App = () => {
  const { data, loading, error } = useFetch('https://jsonplaceholder.typicode.com/posts');

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {data.map(post => (
          <li key={post.id}>
            <h2>{post.title}</h2>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default App;
Explanation
============
i)useFetch Hook:
*) State Management: Uses useState to manage data, loading, and error states.
*) Fetching Data: Uses useEffect to fetch data from the provided URL when the component mounts or when the URL changes.
*) Error Handling: If the fetch request fails, the error is caught and stored in the error state.
*) Loading State: The loading state is set to true when the fetch request starts and false when it completes.

ii)Using the Hook in a Component:
*) The useFetch hook is called with the URL of the data source.
*) The returned data, loading, and error states are used to render the appropriate content.

8.3) UseMediaQuery: Create a hook to manage media query breakpoints for responsive design.
Media Query Breakpoints
========================
Media query breakpoints are specific points defined in CSS where the layout of a web page changes based on the screen size. They are used to create responsive designs that look good on various devices, such as mobile phones, tablets, and desktops. Common breakpoints are typically defined in terms of screen width, such as:
Mobile: 0px to 767px
Tablet: 768px to 1023px
Desktop: 1024px and up

Custom Hook: useMediaQuery
Here's a simple custom hook for managing media query breakpoints:
import { useState, useEffect } from 'react';

function useMediaQuery(query) {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    const listener = () => setMatches(media.matches);
    media.addListener(listener);
    return () => media.removeListener(listener);
  }, [query, matches]);

  return matches;
}

export default useMediaQuery;

Here's an example of how you can use this custom hook in a component:
import React from 'react';
import useMediaQuery from './useMediaQuery';

function ResponsiveComponent() {
  const isMobile = useMediaQuery('(max-width: 767px)');
  const isTablet = useMediaQuery('(min-width: 768px) and (max-width: 1023px)');
  const isDesktop = useMediaQuery('(min-width: 1024px)');

  return (
    <div>
      {isMobile && <p>Mobile view</p>}
      {isTablet && <p>Tablet view</p>}
      {isDesktop && <p>Desktop view</p>}
    </div>
  );
}

export default ResponsiveComponent;
In this example, the useMediaQuery hook is used to check if the current screen width matches mobile, tablet, or desktop breakpoints, and conditionally renders different content based on the screen size.
This custom hook helps keep your components clean and focused on rendering, while the logic for handling media queries is encapsulated within the hook.

8.4) UsePrevious: Implement a custom hook to track and access previous prop or state values.
Custom Hook: usePrevious
import { useEffect, useRef } from 'react';

function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

export default usePrevious;
Example Usage of usePrevious
Let's create a simple component that uses the usePrevious hook to track and display the previous state value.

import React, { useState } from 'react';
import usePrevious from './usePrevious';

function ExampleComponent() {
  const [count, setCount] = useState(0);
  const previousCount = usePrevious(count);

  return (
    <div>
      <h1>Current Count: {count}</h1>
      <h2>Previous Count: {previousCount}</h2>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
    </div>
  );
}

export default ExampleComponent;
Explanation
i) usePrevious Hook:
*) useRef is used to store the previous value. useRef returns a mutable ref object whose .current property is initialized to the passed argument (undefined in this case).
*) useEffect updates the ref with the current value after every render.
*) The hook returns the previous value stored in the ref.
ii) ExampleComponent:
*) count is managed using the useState hook.
*) usePrevious(count) returns the previous value of count before the most recent update.
*) The component displays both the current and previous counts, and provides buttons to increment and decrement the count.

8.5) UseForm: Create a custom hook to manage form state and handle input changes.
useForm Custom Hook
import { useState } from 'react';

// Custom Hook
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues({
      ...values,
      [name]: value,
    });
  };

  const resetForm = () => {
    setValues(initialValues);
  };

  return {
    values,
    handleChange,
    resetForm,
  };
}

export default useForm;

Example Usage of useForm
import React from 'react';
import useForm from './useForm';

function MyForm() {
  const { values, handleChange, resetForm } = useForm({
    name: '',
    email: '',
    password: ''
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(values);
    resetForm();
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Name:</label>
        <input
          type="text"
          name="name"
          value={values.name}
          onChange={handleChange}
        />
      </div>
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={values.email}
          onChange={handleChange}
        />
      </div>
      <div>
        <label>Password:</label>
        <input
          type="password"
          name="password"
          value={values.password}
          onChange={handleChange}
        />
      </div>
      <button type="submit">Submit</button>
    </form>
  );
}

export default MyForm;
Explanation:
==============
i) useForm Hook:
*) useForm takes initialValues as a parameter, which is an object representing the initial state of the form.
*) values state holds the current form values.
*) handleChange updates the specific field in the values state based on the name and value from the input element.
*) resetForm resets the form to the initial values.
ii) Using useForm in a Component:
*) The useForm hook is called with the initial form values.
*) values, handleChange, and resetForm are destructured from the hook.
*) Each input field is linked to the corresponding value in the values state and updates the state using the handleChange function.
*) handleSubmit handles form submission, logs the current form values, and resets the form.

====================================================================================================================================